#!/usr/bin/env ruby

# Copyright (C) 2026 SUSE LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

require 'erb'
require 'open3'
require 'yaml'
require 'optparse'
require 'fileutils'
require 'cgi'
require 'shellwords'
require 'json'

# --- Configuration Management ---

DEFAULT_CONFIG = {
  'flows' => {
    'default' => [
      'private/main',
      'devel/main',
      'origin/factory',
      'suse-private/slfo-main',
      'sle/slfo-main'
    ]
  },
  'default_flow' => 'default',
  'open_by_default' => false,
  'repos' => ['.'],
  'excludes' => [
    ':(exclude)README.md',
    ':(exclude)_scmsync.obsinfo',
    ':(exclude)build.specials.obscpio'
  ],
  'status_colors' => {
    'synced' => '#dcfce7', # Green-100
    'merged' => '#ecfccb', # Lime-100
    'behind' => '#fee2e2', # Red-100
    'diverged' => '#ffedd5', # Orange-100
    'missing' => '#f3f4f6', # Gray-100
    'error' => '#f3f4f6'    # Gray-100
  }
}

STATUS_LABELS = {
  'synced' => 'Synced',
  'merged' => 'Merged',
  'behind' => 'Behind',
  'diverged' => 'Diverged',
  'missing' => 'Missing',
  'error' => 'Error'
}

# Global options will be set during CLI parsing
$options = {}

def log_info(msg)
  puts msg unless $options[:quiet]
end

def load_config
  config_home = ENV['XDG_CONFIG_HOME'] || File.join(Dir.home, '.config')
  config_path = File.join(config_home, 'suse-dashboard.yaml')

  if File.exist?(config_path)
    user_config = YAML.load_file(config_path)
    
    # Simple migration: if old config has 'stages' but no 'flows', convert it
    if user_config['stages'] && !user_config['flows']
      user_config['flows'] = { 'default' => user_config['stages'] }
      user_config['default_flow'] ||= 'default'
      user_config.delete('stages')
    end

    config = DEFAULT_CONFIG.merge(user_config || {})
    # Ensure nested keys are merged correctly if missing in user config
    config['flows'] = DEFAULT_CONFIG['flows'].merge(config['flows'] || {})
    
    # Check if we need to update the file with new defaults (e.g. open_by_default)
    if config.keys.any? { |k| !user_config.key?(k) }
      save_config(config)
    end
    
    config
  else
    FileUtils.mkdir_p(File.dirname(config_path))
    File.write(config_path, DEFAULT_CONFIG.to_yaml)
    log_info "Created default configuration at: #{config_path}"
    DEFAULT_CONFIG
  end
end

def save_config(config)
  config_home = ENV['XDG_CONFIG_HOME'] || File.join(Dir.home, '.config')
  config_path = File.join(config_home, 'suse-dashboard.yaml')
  File.write(config_path, config.to_yaml)
  log_info "Configuration saved to: #{config_path}"
end

# --- Data Structures ---

class ModuleStatus
  attr_accessor :name, :statuses

  def initialize(name)
    @name = name
    @statuses = []
  end
end

# --- Git Operations ---

def run_git_cmd(cmd, dir)
  stdout, stderr, status = Open3.capture3(cmd, chdir: dir)
  return stdout.strip, status.success?
end

def check_pair(dir, upstream, downstream, excludes)
  # Escape arguments
  safe_up = Shellwords.escape(upstream)
  safe_down = Shellwords.escape(downstream)
  safe_excludes = excludes.map { |e| Shellwords.escape(e) }.join(' ')

  # 1. Check if branches exist
  up_sha, up_ok = run_git_cmd("git rev-parse --verify --quiet #{safe_up}", dir)
  down_sha, down_ok = run_git_cmd("git rev-parse --verify --quiet #{safe_down}", dir)

  return { :status => 'missing' } unless up_ok && down_ok

  # 2. Check Content (git diff)
  diff_cmd = "git diff --quiet #{safe_up} #{safe_down} -- #{safe_excludes}"
  _, synced = run_git_cmd(diff_cmd, dir)
  
  return { :status => 'synced' } if synced

  # 3. Ancestry Check
  _, merged = run_git_cmd("git merge-base --is-ancestor #{safe_up} #{safe_down}", dir)
  return { :status => 'merged' } if merged

  _, behind = run_git_cmd("git merge-base --is-ancestor #{safe_down} #{safe_up}", dir)
  
  # For behind or diverged, get the diff (show what is in upstream vs downstream)
  diff_out, _ = run_git_cmd("git diff #{safe_down} #{safe_up} -- #{safe_excludes}", dir)
  
  if behind
    return { :status => 'behind', :diff => diff_out }
  else
    return { :status => 'diverged', :diff => diff_out }
  end
end

def process_repo(repo_path, stages, excludes)
  repo_name = File.basename(File.expand_path(repo_path))
  
  # Check if it has submodules
  submodules_raw, ok = run_git_cmd("git submodule --quiet foreach 'echo $name $path'", repo_path)
  
  modules = []

  if ok && !submodules_raw.empty?
    # Process submodules
    submodules_raw.each_line do |line|
      name, rel_path = line.strip.split(' ', 2)
      next unless name && rel_path
      
      full_path = File.join(repo_path, rel_path)
      modules << analyze_module(name, full_path, stages, excludes)
    end
  else
    # Process as a standalone repo
    modules << analyze_module(repo_name, repo_path, stages, excludes)
  end

  modules
end

def analyze_module(name, path, stages, excludes)
  mod = ModuleStatus.new(name)
  log_info "Processing #{name}..."
  
  (0...stages.length-1).each do |i|
    src = stages[i]
    dst = stages[i+1]
    status = check_pair(path, src, dst, excludes)
    mod.statuses << status
  end
  mod
end

# --- HTML Generation ---

def generate_html(modules, stages, config)
  colors = config['status_colors']
  
  template = <<~ERB
    <!DOCTYPE html>
    <html>
    <head>
      <title>Package Status Dashboard</title>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; }
        table { border-collapse: collapse; width: 100%; border: 1px solid #e5e7eb; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e5e7eb; }
        th { background-color: #f9fafb; font-weight: 600; color: #374151; }
        .status-badge {
          display: inline-block;
          padding: 4px 12px;
          border-radius: 9999px;
          font-size: 14px;
          font-weight: 500;
        }
        .clickable {
          cursor: pointer;
          text-decoration: underline;
        }
        .dimmed {
          opacity: 0.25;
          filter: grayscale(100%);
          background-color: #e5e7eb;
        }
        .modal {
          display: none; 
          position: fixed; 
          z-index: 1000; 
          left: 0;
          top: 0;
          width: 100%; 
          height: 100%; 
          overflow: auto; 
          background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
          background-color: #fefefe;
          margin: 5% auto; 
          padding: 20px;
          border: 1px solid #888;
          width: 80%; 
          max-width: 1200px;
          border-radius: 8px;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
          display: flex;
          flex-direction: column;
          gap: 15px;
        }
        .modal-footer {
          display: flex;
          justify-content: flex-end;
          gap: 10px;
          margin-top: 10px;
          padding-top: 10px;
          border-top: 1px solid #eee;
        }
        .btn {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
          font-size: 14px;
        }
        .btn-secondary {
          background-color: #e5e7eb;
          color: #374151;
        }
        .btn-secondary:hover {
          background-color: #d1d5db;
        }
        .btn-primary {
          background-color: #2563eb;
          color: white;
        }
        .btn-primary:hover {
          background-color: #1d4ed8;
        }
        .close {
          color: #aaa;
          align-self: flex-end;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
          line-height: 1;
        }
        .close:hover,
        .close:focus {
          color: black;
          text-decoration: none;
          cursor: pointer;
        }
        pre {
          background: #f3f4f6;
          padding: 15px;
          border-radius: 4px;
          overflow-x: auto;
          white-space: pre-wrap;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
          font-size: 12px;
          margin: 0;
          max-height: 60vh;
          overflow-y: auto;
        }
      </style>
    </head>
    <body>
      <h1>Package Update Status</h1>
      <p>Generated at <%= Time.now %></p>

      <div style="margin-bottom: 20px; display: flex; gap: 20px; align-items: center;">
        <input type="text" id="searchInput" placeholder="Search modules..." style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px; width: 300px;">
        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; cursor: pointer; user-select: none;">
          <input type="checkbox" id="hideMerged"> Hide all merged/synced
        </label>
      </div>

      <table>
        <thead>
          <tr>
            <th>Module</th>
            <% (0...stages.length-1).each do |i| %>
              <th><%= stages[i] %> &rarr; <%= stages[i+1] %></th>
            <% end %>
          </tr>
        </thead>
        <tbody>
          <% modules.each_with_index do |mod, row_idx| %>
            <tr>
              <td><strong><%= mod.name %></strong></td>
              <% is_dimmed = false %>
              <% mod.statuses.each_with_index do |st_obj, col_idx| %>
                <% 
                   status = st_obj[:status]
                   diff = st_obj[:diff]
                   status_str = status.to_s
                %>
                <td<%= ' class="dimmed"' if is_dimmed %>>
                  <% if diff && !diff.empty? %>
                    <span id="badge-<%= row_idx %>-<%= col_idx %>" 
                          class="status-badge clickable" 
                          style="background-color: <%= colors[status_str] %>"
                          onclick="openModal('badge-<%= row_idx %>-<%= col_idx %>', 'diff-<%= row_idx %>-<%= col_idx %>')">
                      <%= STATUS_LABELS[status_str] || status_str.capitalize %>
                    </span>
                    <div id="diff-<%= row_idx %>-<%= col_idx %>" style="display:none"><%= CGI.escapeHTML(diff) %></div>
                  <% else %>
                    <span class="status-badge" style="background-color: <%= colors[status_str] %>">
                      <%= STATUS_LABELS[status_str] || status_str.capitalize %>
                    </span>
                  <% end %>
                </td>
                <% 
                   is_dimmed = true if ['behind', 'diverged', 'error'].include?(status_str) 
                %>
              <% end %>
            </tr>
          <% end %>
        </tbody>
      </table>

      <div id="diffModal" class="modal">
        <div class="modal-content">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0;">Git Diff</h3>
            <span class="close" onclick="closeModal()">&times;</span>
          </div>
          <pre id="modalText"></pre>
          <div class="modal-footer">
            <button class="btn btn-primary" onclick="ignoreDiff()">Ignore diff</button>
            <button class="btn btn-secondary" onclick="closeModal()">Ack diff</button>
          </div>
        </div>
      </div>

      <script>
        const STATUS_COLORS = <%= config['status_colors'].to_json %>;
        const modal = document.getElementById("diffModal");
        const modalText = document.getElementById("modalText");
        let currentBadgeId = null;

        function openModal(badgeId, diffId) {
          const diffContent = document.getElementById(diffId).textContent;
          modalText.textContent = diffContent;
          currentBadgeId = badgeId;
          modal.style.display = "block";
        }

        function closeModal() {
          modal.style.display = "none";
          currentBadgeId = null;
        }

        function ignoreDiff() {
          if (!currentBadgeId) return;
          
          const badge = document.getElementById(currentBadgeId);
          if (badge) {
            // Update badge to Synced
            badge.textContent = 'Synced';
            badge.style.backgroundColor = STATUS_COLORS['synced'];
            badge.classList.remove('clickable');
            badge.removeAttribute('onclick');
            
            // Re-evaluate dimming for this row
            // Find the parent TR
            const td = badge.closest('td');
            const tr = td.closest('tr');
            if (tr) {
              updateRowDimming(tr);
            }
          }
          closeModal();
        }

        function updateRowDimming(tr) {
          const badges = Array.from(tr.querySelectorAll('.status-badge'));
          let isDimmed = false;

          badges.forEach(badge => {
            const td = badge.closest('td');
            // Apply current dimmed state
            if (isDimmed) {
              td.classList.add('dimmed');
            } else {
              td.classList.remove('dimmed');
            }

            // Determine if NEXT cells should be dimmed
            const statusText = badge.textContent.trim().toLowerCase();
            if (['behind', 'diverged', 'error'].includes(statusText)) {
              isDimmed = true;
            }
          });
        }

        window.onclick = function(event) {
          if (event.target == modal) {
            closeModal();
          }
        }

        document.addEventListener('DOMContentLoaded', () => {
          const table = document.querySelector('table');
          const tbody = table.querySelector('tbody');
          const rows = Array.from(tbody.querySelectorAll('tr'));
          const searchInput = document.getElementById('searchInput');
          const hideMergedCheckbox = document.getElementById('hideMerged');
          const headers = table.querySelectorAll('th');

          function filterRows() {
            const term = searchInput.value.toLowerCase();
            const hideMerged = hideMergedCheckbox.checked;

            rows.forEach(row => {
              const name = row.cells[0].textContent.toLowerCase();
              const matchesSearch = name.includes(term);

              const badges = Array.from(row.querySelectorAll('.status-badge'));
              const statuses = badges.map(b => b.textContent.trim().toLowerCase());
              // Bad statuses: behind, diverged, error
              const hasIssue = statuses.some(s => ['behind', 'diverged', 'error'].includes(s));
              const isAllMerged = !hasIssue;

              let visible = matchesSearch;
              if (hideMerged && isAllMerged) {
                visible = false;
              }

              row.style.display = visible ? '' : 'none';
            });
          }

          searchInput.addEventListener('input', filterRows);
          hideMergedCheckbox.addEventListener('change', filterRows);

          headers.forEach((th, index) => {
            th.style.cursor = 'pointer';
            th.title = "Click to sort";
            th.addEventListener('click', () => {
              const currentRows = Array.from(tbody.querySelectorAll('tr'));
              const multiplier = th.dataset.order === 'asc' ? -1 : 1;
              th.dataset.order = th.dataset.order === 'asc' ? 'desc' : 'asc';
              
              headers.forEach(h => { if(h !== th) h.dataset.order = ''; });

              currentRows.sort((a, b) => {
                const aCell = a.cells[index].textContent.trim();
                const bCell = b.cells[index].textContent.trim();
                return aCell.localeCompare(bCell) * multiplier;
              });

              tbody.append(...currentRows);
            });
          });
        });
      </script>
    </body>
    </html>
  ERB
  ERB.new(template).result(binding)
end

# --- Main CLI ---

$options = {
  output: 'package_dashboard.html',
  open: false,
  flow: nil,
  add_flow: nil,
  quiet: false
}

OptionParser.new do |opts|
  opts.banner = "Usage: package_status_dashboard [options] [REPO_PATHS...]"

  opts.on("-o", "--output FILE", "Specify output HTML file (default: package_dashboard.html)") do |f|
    $options[:output] = f
  end

  opts.on("--open", "Open the generated dashboard with xdg-open") do
    $options[:open] = true
  end

  opts.on("-q", "--quiet", "Suppress all information messages") do
    $options[:quiet] = true
  end

  opts.on("--flow NAME", "Select the flow to use (defaults to 'default_flow' in config)") do |name|
    $options[:flow] = name
  end

  opts.on("--add-flow DEFINITION", "Add a new flow to config (Format: name:stage1:stage2:...)") do |definition|
    $options[:add_flow] = definition
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    puts
    puts "Description:"
    puts "  This tool tracks the git sync status of packages across multiple workflow stages."
    puts "  It supports git submodules or standalone repositories."
    puts "  The status (synced, merged, behind, diverged) is visualized in an HTML dashboard."
    puts
    puts "  Configuration is stored in $XDG_CONFIG_HOME/suse-dashboard.yaml"
    puts "  You can define multiple 'flows' (sequences of branches) in the config."
    exit
  end
end.parse!

config = load_config

# Handle --add-flow
if $options[:add_flow]
  parts = $options[:add_flow].split(':')
  if parts.length < 3
    puts "Error: Invalid flow definition. Format must be 'name:stage1:stage2...'"
    exit 1
  end
  
  flow_name = parts.shift
  # Remaining parts are stages
  config['flows'][flow_name] = parts
  save_config(config)
  log_info "Flow '#{flow_name}' added successfully."
  exit 0
end

# Determine flow to use
flow_name = $options[:flow] || config['default_flow'] || 'default'
stages = config['flows'][flow_name]

unless stages
  puts "Error: Flow '#{flow_name}' not found in configuration."
  puts "Available flows: #{config['flows'].keys.join(', ')}"
  exit 1
end

log_info "Using flow: '#{flow_name}' with stages: #{stages.join(' -> ')}"

# Determine repositories to scan
# 1. CLI arguments
# 2. Configured repos
# 3. Default to current directory (fallback if config is empty somehow)
repo_paths = ARGV.empty? ? (config['repos'] || ['.']) : ARGV

all_modules = []
excludes = config['excludes']

repo_paths.each do |path|
  # Expand path (handles relative paths like '.')
  full_path = File.expand_path(path)
  unless Dir.exist?(full_path)
    # Warnings are likely useful even in quiet mode, but strictly "no info messages" might imply this too.
    # I'll keep warnings unless strict silence is requested. User asked for "prevents all information messages".
    # Usually warnings/errors go to stderr. I'll print to stderr which is standard practice for tools.
    warn "Warning: Directory not found: #{path}"
    next
  end
  log_info "Scanning repository: #{path}"
  all_modules.concat(process_repo(full_path, stages, excludes))
end

if all_modules.empty?
  log_info "No modules found to process."
  exit 0
end

output_file = File.expand_path($options[:output])
File.write(output_file, generate_html(all_modules, stages, config))
log_info "Dashboard generated at: #{output_file}"

if $options[:open] || config['open_by_default']
  system("xdg-open #{output_file}")
end